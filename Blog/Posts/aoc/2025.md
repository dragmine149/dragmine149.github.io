# Advent of code log 2025
Same as last years

## Day 1
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2025/src/day1.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2025/01.png" width="161px">
</a><br>

Today is a safe lock, one which is semi common just turning back and forth. Hence, conversion was super easy.
```rs
#[aoc_generator(day1)]
fn parse(input: &str) -> Vec<i64> {
    input
        .lines()
        .map(|line| {
        	// splits into ['L'/'R', String(number)]
            let info = line.trim().split_at(1);

            let dir = match info.0 {
                "L" => -1,
                "R" => 1,
                _ => panic!("Invalid direction ({:?})", info.0),
            } as i64;

            info.1.parse::<i64>().unwrap() * dir
        })
        .collect::<Vec<i64>>()
}
```
Just convert them into numbers to work with later. Simple. It did take me a while to get the `split_at` method i wanted, but it works quite nice. And ofc, panics if issues because if we can't parse, we can't do day.

### Part 1
The easiest part.

Just mod the input by 100, add/sub that check for 0 and continue. 


### Part 2
Which took me just under 2 hours to complete... All you had to do is implement div and count how many times you div.
![Commit history of 7 commits over the spam of 2 hours in order to complete this day](Blog/Assets/aoc/2025/Screenshot_20251201_152620.png)

Looking back at my first commit checkpoint, i wasn't that far off. Just missing some `else` (due to my tendency to avoid them) and a tad bit of incorrect logic.  And yet, i spent over an hour trying to use loops and structs instead. There was like 15
minutes or so of waiting involved just for AOC to let me submit an answer *had to wait 10 minutes at most for the last submit* 

In the end, kinda looked at a friends repo to see what i was doing wrong. So cheated in a way but as simple as it is, i don't think i could have gotten many "hints" (maybe more input examples but eh)

Hopefully tomorrow doesn't cause as much trouble.

## Day 2
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2025/src/day2.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2025/02.png" width="161px">
</a><br>
Yep definitally easier today, although could have done it much easier in a way...

Oh, and tiles are fixed so they are back (day 1 has been updated as well)

### Part 1
Really not much to save, loop through every entry, and check if the first half is equal to the second half. Only check for even sizes so add
```rs
if size % 2 == 1 {
    continue;
}
```
Number length is gotten by doing
```rs
pub fn get_num_size(num: u64) -> u32 {
    ((num + 1) as f64).log10().ceil() as u32
}
```
and the halves can be split by `num / 10^(len / 2)`. Add the first half to the second half, and repeat. At first i did do `num / 10^(len - 1)` instead but quickly fixed that.

#### String edition
```rs
pub fn find_invalid_str(&self) -> Vec<u64> {
    let mut invalid = vec![];
    for id in self.0..self.1 + 1 {
        let num = id.to_string();
        let length = num.len();
        if length % 2 == 1 {
            continue;
        }
        let data = num.split_at(length / 2);
        if data.0.parse::<u32>() == data.1.parse::<u32>() {
            invalid.push(id);
        }
    }
    invalid
}
```
Yeah, i also did it as a string, which actually semi helped me work out what i needed to do for non-string version. And of cause, the string version takes longer not by a lot but by a bit. Either way, it works

### Part 2
I started part 2 and got most of the way through it, before taking a break going on a walk, having lunch, playing osu! which really did help refresh my mind so i could work out what to do easier.

Still used the same tactic as the first part, get a chunk of the number and keep repeating it until we reach the limit and return. A bit overboard and definitally does way more maths than it should (takes like 7x longer or smth).
The two major issues i ran into where duplicated entries, and invalid numbers. I had a lot of issues with incorrect concatenation maths as i had to redo part 2 from scratch as my part 1 solution wouldn't have been adaptable in any way.

The duplicated entries were easily solved by just `.unique()` from `itertools`, although that would have solved itself (and the second issue) if i just read this
> made only of some sequence of digits repeated at least twice.
earlier...
