# Advent of code log 2025
Same as last years

## Day 1
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2025/src/day01.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2025/01.png" width="161px">
</a><br>

Today is a safe lock, one which is semi common just turning back and forth. Hence, conversion was super easy.
```rs
#[aoc_generator(day1)]
fn parse(input: &str) -> Vec<i64> {
    input
        .lines()
        .map(|line| {
        	// splits into ['L'/'R', String(number)]
            let info = line.trim().split_at(1);

            let dir = match info.0 {
                "L" => -1,
                "R" => 1,
                _ => panic!("Invalid direction ({:?})", info.0),
            } as i64;

            info.1.parse::<i64>().unwrap() * dir
        })
        .collect::<Vec<i64>>()
}
```
Just convert them into numbers to work with later. Simple. It did take me a while to get the `split_at` method i wanted, but it works quite nice. And ofc, panics if issues because if we can't parse, we can't do day.

### Part 1
The easiest part.

Just mod the input by 100, add/sub that check for 0 and continue. 


### Part 2
Which took me just under 2 hours to complete... All you had to do is implement div and count how many times you div.
![Commit history of 7 commits over the spam of 2 hours in order to complete this day](Blog/Assets/aoc/2025/Screenshot_20251201_152620.png)

Looking back at my first commit checkpoint, i wasn't that far off. Just missing some `else` (due to my tendency to avoid them) and a tad bit of incorrect logic.  And yet, i spent over an hour trying to use loops and structs instead. There was like 15
minutes or so of waiting involved just for AOC to let me submit an answer *had to wait 10 minutes at most for the last submit* 

In the end, kinda looked at a friends repo to see what i was doing wrong. So cheated in a way but as simple as it is, i don't think i could have gotten many "hints" (maybe more input examples but eh)

Hopefully tomorrow doesn't cause as much trouble.

## Day 2
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2025/src/day02.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2025/02.png" width="161px">
</a><br>
Yep definitally easier today, although could have done it much easier in a way...

Oh, and tiles are fixed so they are back (day 1 has been updated as well)

### Part 1
Really not much to save, loop through every entry, and check if the first half is equal to the second half. Only check for even sizes so add
```rs
if size % 2 == 1 {
    continue;
}
```
Number length is gotten by doing
```rs
pub fn get_num_size(num: u64) -> u32 {
    ((num + 1) as f64).log10().ceil() as u32
}
```
and the halves can be split by `num / 10^(len / 2)`. Add the first half to the second half, and repeat. At first i did do `num / 10^(len - 1)` instead but quickly fixed that.

#### String edition
```rs
pub fn find_invalid_str(&self) -> Vec<u64> {
    let mut invalid = vec![];
    for id in self.0..self.1 + 1 {
        let num = id.to_string();
        let length = num.len();
        if length % 2 == 1 {
            continue;
        }
        let data = num.split_at(length / 2);
        if data.0.parse::<u32>() == data.1.parse::<u32>() {
            invalid.push(id);
        }
    }
    invalid
}
```
Yeah, i also did it as a string, which actually semi helped me work out what i needed to do for non-string version. And of cause, the string version takes longer not by a lot but by a bit. Either way, it works

### Part 2
I started part 2 and got most of the way through it, before taking a break going on a walk, having lunch, playing osu! which really did help refresh my mind so i could work out what to do easier.

Still used the same tactic as the first part, get a chunk of the number and keep repeating it until we reach the limit and return. A bit overboard and definitally does way more maths than it should (takes like 7x longer or smth).
The two major issues i ran into where duplicated entries, and invalid numbers. I had a lot of issues with incorrect concatenation maths as i had to redo part 2 from scratch as my part 1 solution wouldn't have been adaptable in any way.

The duplicated entries were easily solved by just `.unique()` from `itertools`, although that would have solved itself (and the second issue) if i just read this
> made only of some sequence of digits repeated at least twice.
earlier...

## Day 3
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2025/src/day03.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2025/03.png" width="161px">
</a><br>

*Why can't we just walk down the esclator?*
Anyway, things need power so we shall give them the power they require.

### Part 1
Part 1 is simple, 2 values and 2 numbers. Our input is just single digits so no complex maths, and 0 is out of the question. 0 can be used as a placeholder and we just need to check every number with some `>` comparisions.
At one point i did think about doing a `.unique()` to get largest number, but decided against it. Yet didn't think about doing a `.max()` until talking with a friend after completing part 2.

### Part 2
I went over 3 different iterations in the spam of an hour or so. Mainly trying to take into account the end of the loop as the piority, instead of leaving that for last. It did mean some intresting cases came up like this one
```
BetterBank([9, 8, 7, 6, 5, 4, 3, 2, 1, 1, 1, 1, 1, 1, 1]) -> [9, 8, 7, 6, 1, 1, 1, 1, 2, 3, 4, 5]
```
*Defenitally not the right answer*

After a while, i decided to screw all other ideas and go based on the first solution, aka don't care about the last few numbers, just get the biggest numbers in order. Which helped out and mostly worked,
```rs
fn multi_jolt(&self, jolt_size: usize) -> u64 {
	// initalise vector with jolt_size elements set to 0
    let mut batteries = Vec::with_capacity(jolt_size);
    batteries.extend(repeat_n(0, jolt_size));

	// loop
    for x in 0..self.0.len() {
        let value = *self.0.get(x).unwrap();
        // println!("{:?}", start);
        // check every cell in battery every iteration.
        for cell in 0..batteries.len() {
            if value > *batteries.get(cell).unwrap() {
                batteries[cell] = value;
                for item in batteries.iter_mut().skip(cell + 1) {
                    *item = 0;
                }
                break;
            }
        }
    }

    // println!("{:?} -> {:?}", self, batteries);
    batteries.iter().fold(0, |acc, x| acc * 10 + (*x as u64))
}
```
This worked and gave some obviously broken results, Take `811111111111119` for example, instead of being `[8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9]` it would be `[9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]` that was fixed by just adding a simple check to offset 
where in the battery we should start looking from
```rs
let end = self.0.len() - jolt_size;
let start = x.saturating_sub(end); // if x > end { x - end } else { 0 };
```

Which made getting the answer quick and simple.

#### for fun
Deided to run part 1 against part 2 code, it's the same just with a different vector length. Same answer, just slightly worse time. Which makes sense, part 1 only required 1 loop instead of 2 but its nice to know that unlike day 2 my part 2 code works
for part 1 as well.

## Day 4
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2025/src/day04.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2025/04.png" width="161px">
</a><br>

Its time... we have a grid, lets make a grid!

### Part 1
Spent most of this part just once again remaking the typical `Grid` and `Position` structs. I do have a utility file for it from last year, but i kinda need to improve documentation and stuff on that before i can actually use it. It's been a year so
i've kinda forgotten how most of it works. *(might do that after i finished writing this actually)*

Other than that, it's just simple check every single square. Although what did get me confused for a while was the fact that empty cells `.` did not count. Had to get some external help for that bit of the puzzle.
Also, like always. Had the issue of messed up `Position` and did `Position(y, x)` instead of `Position(x, y)`

### Part 2
Super easy, just take part 1 and loop over it until we can't do any more of part 1. Nothing special here.
