# Advent of code log 2024
My advent of code log for 2024. Not exactly what i did during that day but some funny moments that happened.

WARNING: Spoilers ahead. Some days contains less spoilers than others but some days can contain quite a lot.
Although, if you are reading this you probably don't care that much for aoc spoilers or you have already done it.


## Day 1 {#d01}
Took a while to set up `cargo aoc`, especially when trying to use the incorrect version.<br>
But got set up.

My code isn't the cleanest yet it works, with the two lists. Had to quickly read up on vectors. <br>
First part (including setup) took 1h and the second part took about 42mins.

This seems like an interesting story this year.

## Day 2 {#d02}
Part 1 was fairly simple, took a while to get the looping to work but overall very easy.

Part 2 ended up being a rewrite (refactor) of part 1 alongside some small changes. And then like always, the example data wasn't enough to fully verify that my code was working.
So that took a bit (and 3 vectors) to do.

## Day 3 {#d03}
Regex

Part 1 was simple, just generate a quick regex using [https://regex101.com](https://regex101.com) (Not sponsered) and complete the code. With a triple depth vector... `Vec<Vec<Vec<u64>>>`

Part 2 was also simple, an expansion of the part 1 regex and some refactoring of the code as the triple depth vector kinda worked against me.


## Day 4 {#d04}
Vectors in Vectors

Using a 2d vector made this day quiet easy. Hence Part 1 was completed quite quickly.
Simple, just loop though all characters until the `X` was found and branch off that. At one point i forgot a `=` in my code causing my answer to be wrong. oops

Part 2 took a little more thinking, because of the "misunderstanding" of how the puzzle was meant to be done (good one aoc), it took a bit longer.
As an example
```
M.M
.A.
S.S
```
That had to be found (but in many rotations). The main problem was making sure how to count them all without counting them twice.
Simple solution, go right first then down. Hence you can't recount them at all.

Although, keeping track of 2d vector index's is a bit hard, i thought that my code would not work but it surprisingly did first time.


## Day 5 {#d05}
A day of sorting.

The first puzzle was just some checks. Took a while to mess around with all the borrowing and stuff that rust has but at least i managed to get `all` and `filter` to work.

Part 2 was what i excepted part 1 to be half way though reading it, which was to order everything so that they could be printed.<br>
This took a bit longer, and some `std::cmp::Ordering` usage. My first test upon completing the code, i had the `Ordering::Less` and `Ordering::Greater` the wrong way around, hence resulting in an incorrect output vector. <br>
Although i doubt this ordering wouldn't have mattered as the middle was the only thing that was needed. I still changed it around anyway just to be safe (and to help with debugging if my result was incorrect)


## Day 6 {#d06}
Ouch, Ouch, Ouch, Ouch. That guard must be in quite a bit of pain hitting all those walls.

Parsing the input was fun, converting the map into numbers and getting the guard position.
Using a map full of numbers just remove the need for expensive string manipulation. However due to this number map, a dedicated output function was required to see the map.
```rust
// The dedicated output function to see the map
#[allow(dead_code)]
fn output_map(map: &Vec<Vec<u8>>) {
    let output_map = map
        .iter()
        .map(|line| {
            let mut visible_line = line
                .iter()
                .map(|pos| match pos {
                    &0 => '.',
                    &1 => '#',
                    &2 => '^',
                    &3 => '>',
                    &4 => 'v',
                    &5 => '<',
                    &6 => 'X',
                    &7 => 'O',
                    _ => '?',
                })
                .collect::<String>();
            visible_line.push('\n');
            visible_line
        })
        .collect::<String>();
    println!("{}", output_map);
}
```
Viewing the map is actually quite interesting, all the 'X' all over the place.

Part 1 was just looping until we found a cell that we're not happy with. It's also a loop where updating cells was also in effect. The function did end up returning a lot of information though... Probably should have made some more mutable stuff.
Part 2 was just brute force and some luck, Replacing every cell one by one and checking if the guard can still escape. During coding part 2, i missed this line:
> The new obstruction can't be placed at the guard's starting position - the guard is there right now and would notice.
in the puzzle description. However due to this line of code:
```rust
map[direction_info.0 as usize][direction_info.1 as usize] = 6;
```
which set the square we were just in to an `X` (and some other ways i wrote the program). We got lucky with placing the object were the guard was.


## Day 7 {#d07}
The only day of a competition for the fastest time.

I have a friend that also does advent of code, and due to scheduling and other factors. Today is the only day we can compete against each other for the fastest solution.
The competition was also something we decided to do for fun, a one time thing.

The result of our competition, a draw. I completed part 1 first and they completed part 2 first. The competition had one rule, open the puzzle (Part 1) at the same time. Everything else was up to us.

Besides that, lets talk about day 7.

Part 1 was easily completed with binary, a simple 2 option choice. And then Part 2 ruined that by adding in a third choice and forced the use of a vector wrapping function
```rust
// The wrapping function used to make part 2 work.
fn warp_operators(operators: &mut Vec<u8>) {
    operators[0] += 1;
    for index in 0..(operators.len() - 1) {
        if operators[index] >= 3 {
            operators[index] = 0;
            operators[index + 1] += 1;
        }
    }
}
```

Part 2 was also annoying with the `Concatenation` operator. This took a while to debug whilst not also including updating the code to support the multiple operators.

The first iterator of the concatenation was: `calculation *= 10 + number`. Which well didn't work due to `10 + number` being calculated before the `*=`
The second iterator was:
```rust
calculation *= 10
calculation += number
```
which also didn't work as some of these `numbers` were more than one digit long.
Which lead to the third iteration of:
```rust
calculation = calculation * 10_u64.pow(((number + 1) as f64).log10().ceil() as u32) + number;
```
Which wasn't technically the third iteration (that one used strings to do the same thing).


## Week progress checkpoint {#PC1}
A week of advent of code has been completed, so far it's been relative easy with my code suprising me most of the time with actually getting the correct answer on the first try.
There hasn't been any major difficulty jumps so far. Although the stats for part 2 say differently. I suppose this year part of it is because of my friend helping me in some cases where i might have given up otherwise.

The story has been interesting, every place we've gone to so far to try and find this chief historian, we've done something other than finding the chief.
The calendar image is progressing along nicely, and looks like a mashup of previous years. So far the 5th and 3rd island from 2023 are visible, along with the 2015 christmas tree.
There is also a part on the very left side which is a reference to the 2022 calendar, the green landscape that changes on refresh.

And now, 13 more hours until the start of the second week of AOC.


## Day 8 {#d08}
A semi-complicated day. At first glance it felt very complicated but turned out to not be that bad. I think part of todays puzzle was with how it was worded.
After writing a parser, and then rewriting it. (My first implementation was a standard convert to numbers based one which was way over the top for what is needed).
Could the main solver actually be done. The main solver wasn't too bad to implement, after working out some of the maths and doing some tests.
The annoying thing which took half an hour to debug (ouch) was using a `u8` instead of a `u64`...(a `u8` did not fit all the answer to part 1, hence an answer of `381` was instead `125` due to an overflow)

The second part also sounded hard, but was simple. Just repeat the first part code over and over again until well the map got filled.
I do like this segment of code i wrote:
```rust
// "pos.1" is of type: Vec<(u8, u8)>
if pos.1.len() > 1 {
    for node in pos.1.iter() {
        if !unique.contains(node) {
            unique.push(*node);
        }
    }
}
```
Due to this line in part 2:
> This means that some of the new antinodes will occur at the position of each antenna (unless that antenna is the only one of its frequency).
That segment of code helped with finding the answer which the main segment couldn't do (without causing an infinite loop and hence crashing my terminal in the meantime...)


## Day 9 {#d09}
Files, and a scary day at first glance. A big list of 19,999 numbers and having to work from both sides of the list inwards at the same time.
Annoyingly, today was also the day i was slightly more busy so it took longer to complete.

Enough of that stuff, today was quite fun. I even used a struct for the first time
```rust
#[derive(Debug, Clone, Copy)]
struct Cell {
    empty: bool,
    id: u32,
    size: u32,
    overflow: bool,
}
```

My solution for part 1 was simple, rebuild the file system from the ground up. It just felt easier than having to move stuff back and forth. And because everything already had a size count, the individual characters did not need to move.
A whole block could move at once allowing for easy movement. <br>
Part 1 took a little longer in the fact that i had to split a Cell object up from one into two and "Destroy" some cells not in use anymore.

Thankfully however, due to the way part 1 was written. Part 2 didn't take that long.
```rust
// The only line to change from part 1 code to part 2 code pretty much
cells.iter_mut().for_each(|cell| cell.overflow = true);
```
The overflow variable on the cell object was designed to change how some of the checks worked. Although it's not as simple to explain as it should be, it prevents cells from near the end filling in spaces that are too small for them.
The fun part of the second part was trying to move everything from the back to the front. The final system just ended in looping through the list and finding the first possible option that could fit in that gap. Which worked fine.
This was also the time where the checksum calculation needed to be updated to support `.empty` cells.

Definitely a curve ball but a nice curve ball today.


## Day 10 {#d10}
At first this seemed like some kind of pathing algorithm was required, but no. In fact most of this day was just some function recursion.

Part 1 took a while, requiring like 3 rewrites of the main code function, There were some problems, like forgetting to include a `=` in a `>=` expression. Or doing the looping wrong, or failing to flatten the array correctly.
At the end one of the more annoying issues was this line was messed up:
```rust
// Before: let a = get_pos_of_9(input, &(row_index, cell_index), false);
let a = get_pos_of_9(input, &(cell_index, row_index), false);
```
Due to this, i don't actually know if i needed to rewrite my code 3 times like i did but either way this last solution was definitely better than the previous solutions.

Part 2 was stupidly easy, Just adding one condition to an if statement to allow the code to add more stuff to the vector.


## Day 11 {#d11}
well... yeah AAAAAAAA, a long day today...<br>
Normally i spend an hour or two, not like 5 hours *sigh*, but there was a good reason today.

Part 1 is a simple part, follow some rules, do some looping and complete.
The only real interesting thing was the fact that [Day 7](<2024#Day 7 {#d07}>) came in handy. with this line:
```rust
let number_size = ((self.number + 1) as f64).log10().ceil() as u32;
```
This line was used as an optimization for day 7, removing the need of strings but also worked really well here when splitting the numbers.
```rust
let stone_a = self.number / 10_usize.pow(number_size / 2);
let stone_b = self.number % 10_usize.pow(number_size / 2);
```
It works by getting the size of the number, or more accurately how many times do you need to times 10 by 10 to get that number. But by doing so, it also gets the length. <br>
Example: `1_000_000_000` gives a result of `10` (thanks to the `+1` moving it above the limit of `9` and into `10` due to `ceiling`). <br>
By doing `10 / 2`, we can tell the mid way point of the number. And then using `10^5` (`=100_000`) we have a number we can divide to get each half. <br>
To make it more obvious, lets use `1_234_567_890`. <br>
Rust uses `/` as the divisor (how many times y goes into x) and `%` as the modulus (how much is left over when y can't go into x).
By using this, `stone_a` would return `1_234_500_000` as `67_890 < 100_000` and can't fit in anymore. Hence `stone_b` would return `67_890`.

The whole point of using maths here was to optimise the code as then we didn't need to convert the number into a string, split the string in two and convert each half individually back to a number. This would have been expensive.
I was a bit worried some numbers might have overflowed due to the use of `f64` but no numbers reached that high thankfully.

Part 2: Really small and easy. Just change one number in your code. Simple right? right? <br>
NO. <br>
Part 2 ended up being so complicated that even after a lot of research i visited [reddit](https://reddit.com/r/adventofcode) just to find a reference to "Lantern fish" (yeah i looked at spoilers but that didn't help much).
"Lantern Fish" is a reference from [2021 Day 6](https://adventofcode.com/2021/day/6) which had a similar issues, everything kept duplicating.

But before that, what did i do and research?

A lot,

We had a red herring today, although it was disguised as no it's part of the puzzle. This line:
> No matter how the stones change, **their order is preserved**

Yeah, the ordering didn't matter at all. Instead of well:
```rust
// Source: https://github.com/dragmine149/DragAOC/commit/79d4c8b906f522a5aa01c8b6e4bf7bbd8e980286#diff-f170fd02ff6c3c1063704e18f3c970831a1ec4e392c874dfe9c5f99d61868d62L81
for (stone_index, stone) in new_stones.iter() {
    stones.insert(*stone_index, *stone);
}
```
Inserting at a specific index, just shoving them on the end of the array was enough. surprisingly this reduced the time taken by a lot, probably because rust didn't have to go and reorder the array every time we added something.
By making this change, part 1 time went from around `7.41s` (Went up to around `9.38s` whilst benchmarking with sample size of 100) seconds down to Millisecond.
This worked because stones never interacted with one another so hence it didn't matter where they were (which also helped the next optimization).

The second optimization took forever. At first i thought i needed to do something from [2022 day 11](https://adventofcode.com/2022/day/11) where well we had to keep numbers smaller. But this was a different case and didn't work at all for this case.
So after trying to research other ways of reducing numbers and heading to reddit and finding the "Lantern Fish" reference which i kinda forgot about the 2021 puzzles even though i had already done it. (Doesn't help the files weren't in the repo).

Although even then it still took a while to figure out what system to use. Eventually i gave every stone a count of how many stones they have, changed a lot of the logic multiple times (90% of which wasn't committed).
To end up with my current answer. Which thankfully completed in a couple of millisecond.

Part 2 was funny in some cases, at the start whilst trying to brute force. My terminal kept crashing due to "Out of memory". This was after about 44->45 blinks and 500 million stones. Makes sense why it would crash then.

Whilst i was checking reddit, there seemed to be 2 possible solutions. One along the way i did it and another using memorization (storing the result of a function to not have to calculate it again later).
The memorization solution is an interesting one, although it would reduce the time having to recalculate everything due to still using trillions of numbers, would you still have enough memory to contain everything?
Although we can store a lot more numbers at once than we can with letters. Even if i did try and implement that solution into my p2 now, it wouldn't make much of a difference. In the end, i only had `3744` unique stones.
Although some might have helped (like ones which also follow the `2024` pattern but started later). But i wouldn't be surprised if most of them were unique enough where caching the results wouldn't have done much.
If it did then well, lucky but at the point where times are already in the millisecond, not really much point trying to optimise it even more.


## Day 12 {#d12}
Too long, and the first day when AOC beat me... (solved p2 after solving day 14)

At first glance, simple. Just get the area, get the borders and be done. Which still took a while on its own. Working out how to loop though all the neighbours was eventually done thanks to a stack.
Although these fences are expensive... Someone please help these elves.

The second part is what, however took multiple days and the longest. Working out how to get the how many sides the farmland had.
The first attempt was simple, run around the outside wall (whilst keeping the wall on the left). This method worked until you reached an outside corner, or the inner wall.
The inner wall was hard as you had to find a start location not halfway on a wall. And the outer corners were hard because you had no borders on that square to reference.

Eventually, i threw everything out and made a new system, a segment based system. Each border will be put into a segment that fits most with that border. This worked way better, until some weren't being categorised correctly due to the stack.
The original way i solved this, was by replacing the stack for a queue instead, however this caused a memory issue due to the terminal crashing.

It was only after talking about it that i solved it. The solution, re-run the entire system but worry about the wall locations as well.
It's not complex but its been too long for me to be bothered to talk about it.


## Day 13 {#d13}
Math. Aka research and more research and looking on reddit.

First off though, the input. That took a while to parse. At first i was thinking about going through line by line and doing some condition flipping and other stuff, until i remembered regex and used that instead.
The regex i eventually used is: [https://regex101.com/r/5w0bA7/1](https://regex101.com/r/5w0bA7/1). It's a bit of a chaotic regex but gets the job done.

I've been busy in the morning so whils doing other stuff i was half wondering on if there is a better way than to brute force it up to 10,000 times per machine. Which eventually i came to remember about simultaneous equations....
Although... then started the multi-hour long research session of trying to implement them because they are not fun to implement. (Can't just do it like we can in desmos...)

Eventually i gave up and searched reddit for a solution. The many different attempts i tried just failed. (But i get a point for being on the right track right?)

Part 2 took a little longer than just changing the code, due to using `u8` instead of `u64` again... I only noticed this as i was changing the outputs so i didn't convert from `f64` to `u8` then to `u64` (jumped from `f64` straight to `u64`)

Maths is a pain today...


## Day 14 {#d14}
Why does the toilets need robot security? And why 500 of them??

Either way, day 14 is a nice break from the previous two days. Something simple.
The first part was a bit of copy + paste from day 12 (with the `Position` Struct), another regex parsing. (Thankfully `.parse()` also works with negative numbers) and a bit of failed math and conditions.
Part 1 didn't have many problems, the main ones being:
- debug output grid looping incorrect
- Missing a `=` in a `>=` statement

Other than that, part 1 was fairly quick. <br>
Part 2 took a while longer, although part of that while was due to having a 1-ish hour break.

At first, i tried to search the first 1k seconds for this christmas tree easter egg (wait, easter in christmas?). But with no luck. <br>
Then i tried to get all the lines where there were a lot of robots on that line, but that took way too long so also failed. <br>
This next version worked, using some maths get the IQR (interquartile range) of the robots and see if there are so many within that range. Which i got lucky for...

My theory here for IQR was that the image would just be a tree and this should give us the bottom line of the tree at least. No, the tree was tiny (this wouldn't have worked) but the border was big enough... <br>
This system still did 25-ish seconds to run though. SO, i attempted to speed it up by seeing if there was a certain amount of robots (>= 300) in a quadrant at one time. Considering the tree had most robots. <br>
This new system has a small issue where if the tree is centered it might not work but thankfully that wasn't the case and the tree was found in a much more reasonable time `<1 second`


## Week Progress Checkpoint 2 {#PC2}
It's been another week already...

If i was doing this year alone i might have stopped at [day 12](<2024#Day 12 {#d12}>) considering how hard that is, but because i'm doing it with two friends.
The puzzles have started to get harder but the story is interesting (and stupid). Yet hopefully the days to come can still be fun...

At least every day so far has been 2*'ed, Just half of december to go.
