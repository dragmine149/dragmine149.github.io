# Advent of code log 2024
My advent of code log for 2024. Not exactly what i did during that day but some funny moments that happened.

WARNING: Spoilers ahead. Some days contains less spoilers than others but some days can contain quite a lot.
Although, if you are reading this you probably don't care that much for aoc spoilers or you have already done it.


## Day 1 {#d01}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day01.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/01.png" width="161px">
</a><br>

Took a while to set up `cargo aoc`, especially when trying to use the incorrect version.<br>
But got set up.

My code isn't the cleanest yet it works, with the two lists. Had to quickly read up on vectors. <br>
First part (including setup) took 1h and the second part took about 42mins.

This seems like an interesting story this year.

## Day 2 {#d02}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day02.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/02.png" width="161px">
</a><br>

Part 1 was fairly simple, took a while to get the looping to work but overall very easy.

Part 2 ended up being a rewrite (refactor) of part 1 alongside some small changes. And then like always, the example data wasn't enough to fully verify that my code was working.
So that took a bit (and 3 vectors) to do.

## Day 3 {#d03}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day03.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/03.png" width="161px">
</a><br>

Regex

Part 1 was simple, just generate a quick regex using [https://regex101.com](https://regex101.com) (Not sponsered) and complete the code. With a triple depth vector... `Vec<Vec<Vec<u64>>>`

Part 2 was also simple, an expansion of the part 1 regex and some refactoring of the code as the triple depth vector kinda worked against me.


## Day 4 {#d04}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day04.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/04.png" width="161px">
</a><br>

Vectors in Vectors

Using a 2d vector made this day quiet easy. Hence Part 1 was completed quite quickly.
Simple, just loop though all characters until the `X` was found and branch off that. At one point i forgot a `=` in my code causing my answer to be wrong. oops

Part 2 took a little more thinking, because of the "misunderstanding" of how the puzzle was meant to be done (good one aoc), it took a bit longer.
As an example
```
M.M
.A.
S.S
```
That had to be found (but in many rotations). The main problem was making sure how to count them all without counting them twice.
Simple solution, go right first then down. Hence you can't recount them at all.

Although, keeping track of 2d vector index's is a bit hard, i thought that my code would not work but it surprisingly did first time.


## Day 5 {#d05}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day05.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/05.png" width="161px">
</a><br>

A day of sorting.

The first puzzle was just some checks. Took a while to mess around with all the borrowing and stuff that rust has but at least i managed to get `all` and `filter` to work.

Part 2 was what i excepted part 1 to be half way though reading it, which was to order everything so that they could be printed.<br>
This took a bit longer, and some `std::cmp::Ordering` usage. My first test upon completing the code, i had the `Ordering::Less` and `Ordering::Greater` the wrong way around, hence resulting in an incorrect output vector. <br>
Although i doubt this ordering wouldn't have mattered as the middle was the only thing that was needed. I still changed it around anyway just to be safe (and to help with debugging if my result was incorrect)


## Day 6 {#d06}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day06.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/06.png" width="161px">
</a><br>

Ouch, Ouch, Ouch, Ouch. That guard must be in quite a bit of pain hitting all those walls.

Parsing the input was fun, converting the map into numbers and getting the guard position.
Using a map full of numbers just remove the need for expensive string manipulation. However due to this number map, a dedicated output function was required to see the map.
```rust
// The dedicated output function to see the map
#[allow(dead_code)]
fn output_map(map: &Vec<Vec<u8>>) {
    let output_map = map
        .iter()
        .map(|line| {
            let mut visible_line = line
                .iter()
                .map(|pos| match pos {
                    &0 => '.',
                    &1 => '#',
                    &2 => '^',
                    &3 => '>',
                    &4 => 'v',
                    &5 => '<',
                    &6 => 'X',
                    &7 => 'O',
                    _ => '?',
                })
                .collect::<String>();
            visible_line.push('\n');
            visible_line
        })
        .collect::<String>();
    println!("{}", output_map);
}
```
Viewing the map is actually quite interesting, all the 'X' all over the place.

Part 1 was just looping until we found a cell that we're not happy with. It's also a loop where updating cells was also in effect. The function did end up returning a lot of information though... Probably should have made some more mutable stuff.
Part 2 was just brute force and some luck, Replacing every cell one by one and checking if the guard can still escape. During coding part 2, i missed this line:
> The new obstruction can't be placed at the guard's starting position - the guard is there right now and would notice.
in the puzzle description. However due to this line of code:
```rust
map[direction_info.0 as usize][direction_info.1 as usize] = 6;
```
which set the square we were just in to an `X` (and some other ways i wrote the program). We got lucky with placing the object were the guard was.


## Day 7 {#d07}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day07.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/07.png" width="161px">
</a><br>

The only day of a competition for the fastest time.

I have a friend that also does advent of code, and due to scheduling and other factors. Today is the only day we can compete against each other for the fastest solution.
The competition was also something we decided to do for fun, a one time thing.

The result of our competition, a draw. I completed part 1 first and they completed part 2 first. The competition had one rule, open the puzzle (Part 1) at the same time. Everything else was up to us.

Besides that, lets talk about day 7.

Part 1 was easily completed with binary, a simple 2 option choice. And then Part 2 ruined that by adding in a third choice and forced the use of a vector wrapping function
```rust
// The wrapping function used to make part 2 work.
fn warp_operators(operators: &mut Vec<u8>) {
    operators[0] += 1;
    for index in 0..(operators.len() - 1) {
        if operators[index] >= 3 {
            operators[index] = 0;
            operators[index + 1] += 1;
        }
    }
}
```

Part 2 was also annoying with the `Concatenation` operator. This took a while to debug whilst not also including updating the code to support the multiple operators.

The first iterator of the concatenation was: `calculation *= 10 + number`. Which well didn't work due to `10 + number` being calculated before the `*=`
The second iterator was:
```rust
calculation *= 10
calculation += number
```
which also didn't work as some of these `numbers` were more than one digit long.
Which lead to the third iteration of:
```rust
calculation = calculation * 10_u64.pow(((number + 1) as f64).log10().ceil() as u32) + number;
```
Which wasn't technically the third iteration (that one used strings to do the same thing).


## Week progress checkpoint {#PC1}
A week of advent of code has been completed, so far it's been relative easy with my code suprising me most of the time with actually getting the correct answer on the first try.
There hasn't been any major difficulty jumps so far. Although the stats for part 2 say differently. I suppose this year part of it is because of my friend helping me in some cases where i might have given up otherwise.

The story has been interesting, every place we've gone to so far to try and find this chief historian, we've done something other than finding the chief.
The calendar image is progressing along nicely, and looks like a mashup of previous years. So far the 5th and 3rd island from 2023 are visible, along with the 2015 christmas tree.
There is also a part on the very left side which is a reference to the 2022 calendar, the green landscape that changes on refresh.

And now, 13 more hours until the start of the second week of AOC.


## Day 8 {#d08}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day08.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/08.png" width="161px">
</a><br>

A semi-complicated day. At first glance it felt very complicated but turned out to not be that bad. I think part of todays puzzle was with how it was worded.
After writing a parser, and then rewriting it. (My first implementation was a standard convert to numbers based one which was way over the top for what is needed).
Could the main solver actually be done. The main solver wasn't too bad to implement, after working out some of the maths and doing some tests.
The annoying thing which took half an hour to debug (ouch) was using a `u8` instead of a `u64`...(a `u8` did not fit all the answer to part 1, hence an answer of `381` was instead `125` due to an overflow)

The second part also sounded hard, but was simple. Just repeat the first part code over and over again until well the map got filled.
I do like this segment of code i wrote:
```rust
// "pos.1" is of type: Vec<(u8, u8)>
if pos.1.len() > 1 {
    for node in pos.1.iter() {
        if !unique.contains(node) {
            unique.push(*node);
        }
    }
}
```
Due to this line in part 2:
> This means that some of the new antinodes will occur at the position of each antenna (unless that antenna is the only one of its frequency).
That segment of code helped with finding the answer which the main segment couldn't do (without causing an infinite loop and hence crashing my terminal in the meantime...)


## Day 9 {#d09}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day09.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/09.png" width="161px">
</a><br>

Files, and a scary day at first glance. A big list of 19,999 numbers and having to work from both sides of the list inwards at the same time.
Annoyingly, today was also the day i was slightly more busy so it took longer to complete.

Enough of that stuff, today was quite fun. I even used a struct for the first time
```rust
#[derive(Debug, Clone, Copy)]
struct Cell {
    empty: bool,
    id: u32,
    size: u32,
    overflow: bool,
}
```

My solution for part 1 was simple, rebuild the file system from the ground up. It just felt easier than having to move stuff back and forth. And because everything already had a size count, the individual characters did not need to move.
A whole block could move at once allowing for easy movement. <br>
Part 1 took a little longer in the fact that i had to split a Cell object up from one into two and "Destroy" some cells not in use anymore.

Thankfully however, due to the way part 1 was written. Part 2 didn't take that long.
```rust
// The only line to change from part 1 code to part 2 code pretty much
cells.iter_mut().for_each(|cell| cell.overflow = true);
```
The overflow variable on the cell object was designed to change how some of the checks worked. Although it's not as simple to explain as it should be, it prevents cells from near the end filling in spaces that are too small for them.
The fun part of the second part was trying to move everything from the back to the front. The final system just ended in looping through the list and finding the first possible option that could fit in that gap. Which worked fine.
This was also the time where the checksum calculation needed to be updated to support `.empty` cells.

Definitely a curve ball but a nice curve ball today.


## Day 10 {#d10}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day10.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/10.png" width="161px">
</a><br>

At first this seemed like some kind of pathing algorithm was required, but no. In fact most of this day was just some function recursion.

Part 1 took a while, requiring like 3 rewrites of the main code function, There were some problems, like forgetting to include a `=` in a `>=` expression. Or doing the looping wrong, or failing to flatten the array correctly.
At the end one of the more annoying issues was this line was messed up:
```rust
// Before: let a = get_pos_of_9(input, &(row_index, cell_index), false);
let a = get_pos_of_9(input, &(cell_index, row_index), false);
```
Due to this, i don't actually know if i needed to rewrite my code 3 times like i did but either way this last solution was definitely better than the previous solutions.

Part 2 was stupidly easy, Just adding one condition to an if statement to allow the code to add more stuff to the vector.


## Day 11 {#d11}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day11.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/11.png" width="161px">
</a><br>

well... yeah AAAAAAAA, a long day today...<br>
Normally i spend an hour or two, not like 5 hours *sigh*, but there was a good reason today.

Part 1 is a simple part, follow some rules, do some looping and complete.
The only real interesting thing was the fact that [Day 7](<2024#Day 7 {#d07}>) came in handy. with this line:
```rust
let number_size = ((self.number + 1) as f64).log10().ceil() as u32;
```
This line was used as an optimization for day 7, removing the need of strings but also worked really well here when splitting the numbers.
```rust
let stone_a = self.number / 10_usize.pow(number_size / 2);
let stone_b = self.number % 10_usize.pow(number_size / 2);
```
It works by getting the size of the number, or more accurately how many times do you need to times 10 by 10 to get that number. But by doing so, it also gets the length. <br>
Example: `1_000_000_000` gives a result of `10` (thanks to the `+1` moving it above the limit of `9` and into `10` due to `ceiling`). <br>
By doing `10 / 2`, we can tell the mid way point of the number. And then using `10^5` (`=100_000`) we have a number we can divide to get each half. <br>
To make it more obvious, lets use `1_234_567_890`. <br>
Rust uses `/` as the divisor (how many times y goes into x) and `%` as the modulus (how much is left over when y can't go into x).
By using this, `stone_a` would return `1_234_500_000` as `67_890 < 100_000` and can't fit in anymore. Hence `stone_b` would return `67_890`.

The whole point of using maths here was to optimise the code as then we didn't need to convert the number into a string, split the string in two and convert each half individually back to a number. This would have been expensive.
I was a bit worried some numbers might have overflowed due to the use of `f64` but no numbers reached that high thankfully.

Part 2: Really small and easy. Just change one number in your code. Simple right? right? <br>
NO. <br>
Part 2 ended up being so complicated that even after a lot of research i visited [reddit](https://reddit.com/r/adventofcode) just to find a reference to "Lantern fish" (yeah i looked at spoilers but that didn't help much).
"Lantern Fish" is a reference from [2021 Day 6](https://adventofcode.com/2021/day/6) which had a similar issues, everything kept duplicating.

But before that, what did i do and research?

A lot,

We had a red herring today, although it was disguised as no it's part of the puzzle. This line:
> No matter how the stones change, **their order is preserved**

Yeah, the ordering didn't matter at all. Instead of well:
```rust
// Source: https://github.com/dragmine149/DragAOC/commit/79d4c8b906f522a5aa01c8b6e4bf7bbd8e980286#diff-f170fd02ff6c3c1063704e18f3c970831a1ec4e392c874dfe9c5f99d61868d62L81
for (stone_index, stone) in new_stones.iter() {
    stones.insert(*stone_index, *stone);
}
```
Inserting at a specific index, just shoving them on the end of the array was enough. surprisingly this reduced the time taken by a lot, probably because rust didn't have to go and reorder the array every time we added something.
By making this change, part 1 time went from around `7.41s` (Went up to around `9.38s` whilst benchmarking with sample size of 100) seconds down to Millisecond.
This worked because stones never interacted with one another so hence it didn't matter where they were (which also helped the next optimization).

The second optimization took forever. At first i thought i needed to do something from [2022 day 11](https://adventofcode.com/2022/day/11) where well we had to keep numbers smaller. But this was a different case and didn't work at all for this case.
So after trying to research other ways of reducing numbers and heading to reddit and finding the "Lantern Fish" reference which i kinda forgot about the 2021 puzzles even though i had already done it. (Doesn't help the files weren't in the repo).

Although even then it still took a while to figure out what system to use. Eventually i gave every stone a count of how many stones they have, changed a lot of the logic multiple times (90% of which wasn't committed).
To end up with my current answer. Which thankfully completed in a couple of millisecond.

Part 2 was funny in some cases, at the start whilst trying to brute force. My terminal kept crashing due to "Out of memory". This was after about 44->45 blinks and 500 million stones. Makes sense why it would crash then.

Whilst i was checking reddit, there seemed to be 2 possible solutions. One along the way i did it and another using memorization (storing the result of a function to not have to calculate it again later).
The memorization solution is an interesting one, although it would reduce the time having to recalculate everything due to still using trillions of numbers, would you still have enough memory to contain everything?
Although we can store a lot more numbers at once than we can with letters. Even if i did try and implement that solution into my p2 now, it wouldn't make much of a difference. In the end, i only had `3744` unique stones.
Although some might have helped (like ones which also follow the `2024` pattern but started later). But i wouldn't be surprised if most of them were unique enough where caching the results wouldn't have done much.
If it did then well, lucky but at the point where times are already in the millisecond, not really much point trying to optimise it even more.


## Day 12 {#d12}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day12.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/12.png" width="161px">
</a><br>

Too long, and the first day when AOC beat me... (solved p2 after solving day 14)

At first glance, simple. Just get the area, get the borders and be done. Which still took a while on its own. Working out how to loop though all the neighbours was eventually done thanks to a stack.
Although these fences are expensive... Someone please help these elves.

The second part is what, however took multiple days and the longest. Working out how to get the how many sides the farmland had.
The first attempt was simple, run around the outside wall (whilst keeping the wall on the left). This method worked until you reached an outside corner, or the inner wall.
The inner wall was hard as you had to find a start location not halfway on a wall. And the outer corners were hard because you had no borders on that square to reference.

Eventually, i threw everything out and made a new system, a segment based system. Each border will be put into a segment that fits most with that border. This worked way better, until some weren't being categorised correctly due to the stack.
The original way i solved this, was by replacing the stack for a queue instead, however this caused a memory issue due to the terminal crashing.

It was only after talking about it that i solved it. The solution, re-run the entire system but worry about the wall locations as well.
It's not complex but its been too long for me to be bothered to talk about it.


## Day 13 {#d13}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day13.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/13.png" width="161px">
</a><br>

Math. Aka research and more research and looking on reddit.

First off though, the input. That took a while to parse. At first i was thinking about going through line by line and doing some condition flipping and other stuff, until i remembered regex and used that instead.
The regex i eventually used is: [https://regex101.com/r/5w0bA7/1](https://regex101.com/r/5w0bA7/1). It's a bit of a chaotic regex but gets the job done.

I've been busy in the morning so whils doing other stuff i was half wondering on if there is a better way than to brute force it up to 10,000 times per machine. Which eventually i came to remember about simultaneous equations....
Although... then started the multi-hour long research session of trying to implement them because they are not fun to implement. (Can't just do it like we can in desmos...)

Eventually i gave up and searched reddit for a solution. The many different attempts i tried just failed. (But i get a point for being on the right track right?)

Part 2 took a little longer than just changing the code, due to using `u8` instead of `u64` again... I only noticed this as i was changing the outputs so i didn't convert from `f64` to `u8` then to `u64` (jumped from `f64` straight to `u64`)

Maths is a pain today...


## Day 14 {#d14}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day14.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/14.png" width="161px">
</a><br>

Why does the toilets need robot security? And why 500 of them??

Either way, day 14 is a nice break from the previous two days. Something simple.
The first part was a bit of copy + paste from day 12 (with the `Position` Struct), another regex parsing. (Thankfully `.parse()` also works with negative numbers) and a bit of failed math and conditions.
Part 1 didn't have many problems, the main ones being:
- debug output grid looping incorrect
- Missing a `=` in a `>=` statement

Other than that, part 1 was fairly quick. <br>
Part 2 took a while longer, although part of that while was due to having a 1-ish hour break.

At first, i tried to search the first 1k seconds for this christmas tree easter egg (wait, easter in christmas?). But with no luck. <br>
Then i tried to get all the lines where there were a lot of robots on that line, but that took way too long so also failed. <br>
This next version worked, using some maths get the IQR (interquartile range) of the robots and see if there are so many within that range. Which i got lucky for...

My theory here for IQR was that the image would just be a tree and this should give us the bottom line of the tree at least. No, the tree was tiny (this wouldn't have worked) but the border was big enough... <br>
This system still did 25-ish seconds to run though. SO, i attempted to speed it up by seeing if there was a certain amount of robots (>= 300) in a quadrant at one time. Considering the tree had most robots. <br>
This new system has a small issue where if the tree is centered it might not work but thankfully that wasn't the case and the tree was found in a much more reasonable time `<1 second`


## Week Progress Checkpoint 2 {#PC2}
It's been another week already...

If i was doing this year alone i might have stopped at [day 12](<2024#Day 12 {#d12}>) considering how hard that is, but because i'm doing it with two friends.
The puzzles have started to get harder but the story is interesting (and stupid). Yet hopefully the days to come can still be fun...

At least every day so far has been 2*'ed, Just half of december to go.


## Day 15 {#d15}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day15.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/15.png" width="161px">
</a><br>

These robots are dumb. Like, they run around in circles doing nothing for a couple tens of movements.

Asides from the dumb robot logic, todays resulted in a really messy codebase. To the point where i'm pretty sure most of it could be cleaned up in one way or another.
Part 1 was a simple 2d map with some simple logic. Aka check if a robot can move or not, and if so push the boxes in the way. As such, part 1 could be completed nice and quickly with nothing too complex.

Part 2 (like always at this point) once again made things more complex, by increasing the width of the room, and all the boxes. The logic to move the boxes vertically took the longest to solve (and i still don't understand my code).
Horizontally, the boxes acted like they did in the normal room. Hence can use exactly the same code with a direction check to make sure we weren't using the wrong system for the wrong things.
The vertical checks required a different system due to them pushing boxes in a tree like shape sometimes. This tree caused a lot of issues. To the point that i had made this function to make sure the map was still valid:
```rust
// Function to check if the grid is still in tack. (no half boxes left around)
#[allow(dead_code)]
fn check_grid(grid: &[Vec<Location>], direction_count: usize) {
    // Par iter speeds this up slightly considering how often we check it.
    grid.par_iter().for_each(|line| {
        let mut left = false;
        line.iter().for_each(|char| {
            if char.cell == CellType::BoxRight && !left {
                println!("Count: {:?}", direction_count);
                debug_map(grid);
                panic!("Grid is broken!");
            } else {
                left = false;
            }
            if char.cell != CellType::BoxRight && left {
                println!("Count: {:?}", direction_count);
                debug_map(grid);
                panic!("Grid is broken!");
            } else {
                left = false;
            }

            if char.cell == CellType::BoxLeft {
                left = true;
            }
        })
    });
}
```
The function doesn't check everything like the robot or the walls. But the walls were never touched (they couldn't be touched) and the robot had it's own backup system if need be (not like that mattered).

My first attempt at doing the vertical movement was the same with the horizontal and vertical previously. Find the empty space and move all the boxes from that empty space to the robot. This system however had many issues.
As part 1 already used a similar system, expanding it to be double width shouldn't be that hard, but it was. The main issues was with the boxes breaking up due to being processed incorrectly. There were also cases where a box
that shouldn't be touched was being moved, for example:
```
############
##..@.....##
##..[][]..##
##...[]...##
##........##
############
```
The robot would try to move all the boxes down ending up in this result:
```
############
##........##
##..@.....##
##..[][]..##
##...[]...##
############
```
Instead of this result:
```
############
##........##
##..@.[]..##
##..[]....##
##...[]...##
############
```
Eventually i decided to scrap that system, i probably could have got it to work but with all the issues another system was more reliable. And besides, when using this system i was basically recalculating every single box.<br>
To find the empty spaces in the first place, i had to already search for every box, hence i knew everything and yet was trying to recalculate it.

So, rewriting my code to take advantage of the boxes i already knew took a while but was eventually done, then was the fun part of making sure the boxes wouldn't break apart. Which was because of how the boxes were processed...
(I've lost count of how many times the order has mattered... just let me use threading already *pout*)

This was the fun part, and the part which i'm still confused on. In order to make sure the boxes were in the correct order, they had to be sorted. So i ended up with this massive sorting statement:
```rust
// initial sort to make sure everything is the right order
boxes.sort_by(|a, b| {
    if direction == Direction::North {
        if a.0 < b.0 {
            return Ordering::Equal;
        }
        if a.0 > b.0 {
            return Ordering::Less;
        }
    } else if direction == Direction::South {
        if a.0 > b.0 {
            return Ordering::Equal;
        }
        if a.0 < b.0 {
            return Ordering::Less;
        }
    }
    if a.0 > b.0 {
        return Ordering::Greater;
    }
    if a.0 == b.0 {
        return Ordering::Equal;
    }
    if a.0 < b.0 {
        return Ordering::Less;
    }

    Ordering::Equal
});

// and another sort because i forgot to remove this one, yet it is 100% required so i'm keeping it.
boxes.sort_by(|a, b| {
    if a.0 > b.0 {
        return if direction == Direction::South {
            Ordering::Less
        } else {
            Ordering::Greater
        };
    }
    if a.1 < b.1 {
        return if direction == Direction::South {
            Ordering::Less
        } else {
            Ordering::Greater
        };
    }

    if direction == Direction::South {
        Ordering::Greater
    } else {
        Ordering::Less
    }
});
```
Yes, not just one statement but two. And if either are them are not here it breaks. I have no idea why because trying to visualize sorting is also the same as remembering a 2d map index grid.
Originally, it was just a `.sort()` but that caused some issues especially when it came to directional based movement, hence the algorithm needed to be updated. The bottom sort was the original one.
It's a simple make sure that we sort based by Y (vertical height) before X (horizontal). The vertical was important as it needs to start with every box closest to the empty space, otherwise boxes would end up replacing other boxes.

However this caused some issues still, with splitting boxes. So in attempts to fix this, the top statement was introduced. Which made it work somehow... Originally the plan was to have the top statement be better than the bottom statement
and replace it, but because i forgot to take it out during testing, it worked and is now an important part of the code. I tried to remove either but that caused it to break so i have to keep both.

Over the past couple of days, these AOC have been taking like half the day (along with doing other stuff of cause) instead of the normal knock it out in the morning session. But neither less, time to keep pressing forward.


## Day 16 {#d16}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day16.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/16.png" width="161px">
</a><br>

Everything makes sense today, although, are all reindeer that smart?
Either way, today was searching. An algorithm done many a time and is still commonly used. There seem to be a lot of searching algorithms, but i'm not sure which one i've done specifically.
However, i'm guessing it's `Dijkstra` due to my system sounding similar to one of my friends systems.

Whilst implementing that system, i had to rewrite it at least once. My first attempt required returning the score of the final path, which was causing issues. Especially with the branches.
The second attempt was just setting the score of each cell to the minimum required score to reach that cell, which worked much better than before. Afterwards it was just a simple get the score in the end cell.

Oh right, the start and end cells are always in the same place. Probably didn't need to add a searching function for this but whatever
```rust
// Said searching function
fn find_first_cell_of_type(&self, cell_type: &Cell) -> Position {
    for (line_index, line) in self.grid.iter().enumerate() {
        for (pos_index, pos) in line.iter().enumerate() {
            if pos == cell_type {
                return Position(line_index, pos_index);
            }
        }
    }

Position(0, 0)
}
```

The second part took the longest, due to one issue which i'll explain later.
This part was hard, because not only did we need the amount of nodes of the previous route, but all the nodes of any route that would reach the end in the same amount of time.
The easiest way to do this, run the part 1 code and then work backwards until the start finding all the routes. Route nodes follow two rules, each corner must be the same or 1k above. each forward must be the same or 1 above.

Having these two rules allowed us to work backwards, as anything not of these rules would be of a different path and hence a longer path. In order to help with debugging, i ended up making this function.
```rust
#[allow(dead_code)]
fn debug_score(&self, digit_count: usize) {
    for line in self.score.iter() {
        let info = line
            .iter()
            .map(|cell| {
                let cell_score = cell.get_smallest_num();
                if cell_score == 0 {
                    " ".repeat(digit_count + 1)
                } else {
                    // https://stackoverflow.com/a/50458236/14621075
                    format!("{:0>width$} ", cell_score, width = digit_count).to_string()
                }
            })
            .collect::<String>();
        println!("{:?}", info);
    }
}
```
Which allowed for some cool pictures of the map laid out like this one:
![The maze for example 2 printed out in all it's number glory](Blog/Assets/aoc/14-1.png)

Anyway, enough with that detour. The main story.

Part 2 seemed simple but just kept running into issue after issue, although the issue was that example data was passing and real data was not passing.
I ended up rewriting part of the code and making a big mess of this once clean file just to solve the issue. Eventually it came down to this function:
```rust
fn get_last_2_digits(num: u64) -> u64 {
    num % 100
}
```
Well, you see it? The problem that is? No? (okay, i'm just slightly joking with these questions)
The issue, is that it's only the last 2 digits... Now this function is used for two things:
- Get the forward distance (to make sure it's one less than the previous)
- **Checking if we are at the start of the maze** (Because a result of 0 means no forward)
Now, this second condition is what is important. Due to the example mazes having `< 100` forward movements, everything is fine. But put it on real data where some cells you move up to like `400` times to get there... then the issue occurs.
The system was basically thinking it had "reached the start of the maze" whilst not finishing the whole path...

Aside from that pain, today surprisingly that hard, it was kind of calm and simple. Maybe it's because we got to have a break from finding this historian...

## Day 17 {#d17}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day17.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/17.png" width="161px">
</a><br>

Well, of cause the teleportation devices has to break at some point. When has a teleportation device not broke?
Either way, today part 1 was defenitally fun. Build a computer, super easy to do and the actuall fun part of today. The computer was built in a matter of minutes and worked as expected first time (Other than fixing the regex parsing...)

Part 2 took a long time, to the point where i gave up and searched reddit, eventually copying an answer and converting it to rust.
The difficult part of part 2 was not the code but understanding how it worked and implementing it. So to try and explain it...

When the computer generates it output for any given value of a, it will always take 8 a's before going onto the next number.
The right most bit is always 0 and it increments the left most bit before overflowing onto the bit to the right. Eventually incrememnting all bits.

In order to get where the program outputs itself, we need to find a value of a that uses the last 10 bits to get that output. Hence a stack with backtracking.
Until the whole number is discovered, the value of a is shifted across by 3 bits and added another 3 bits. The computer then computs this value. If the computed vlaue is not what we are looking for, we skip it.
Whilst computing these values, we only check the last X digits of the program with all of the digits of the outputted value. This ensures we have something correct before going onto the next octal.

Eventually, the stack will be cleared and from all the possible values calculated when the whole length of the program is the output, we take the lowest and output that.

Even after explaining it, i probably wouldn't be able to generate the algorithm to have done that. Although it doesn't seem as complicated, it still is a complex thing to get your head around, and it doesn't really help we're working in base 8 (instead of base 2 or base 10)


## Day 18 {#d18}
<a href="https://github.com/dragmine149/DragAOC/blob/main/aoc-2024/src/day18.rs">
  <img src="https://raw.githubusercontent.com/dragmine149/DragAOC/refs/heads/main/.aoc_tiles/tiles/2024/18.png" width="161px">
</a><br>

Day 16 version 2, well mostly.

And as such, a day i've been hoping for a real simple day with nothing too complicated.

Part 1 was easy, just copy and past from day 16 and make some minor modifications. The only real issue, well that's best explained in this reddit post: [[2024 Day 18] Reading was hard today](https://www.reddit.com/r/adventofcode/comments/1hgv9py/2024_day_18_reading_was_hard_today/)
Part 2, also easy. just brute force it. Sart after 1024 and keep running part 1 until you couldn't complete the maze, then you have the coords. This did however take `>100s` to run, but due to tiny data was fesable.

I could have just stopped with part 2 taking forever, but to make sure that it doesn't take forever, i used a slightly different method to decrease the time down to around 1.4 seconds.

This new method generated the path, and only regenerated the path if a memory block fell on any spot of the path that was already generated. Hence we didn't need to search every cell every frame just to find a path even if our already know path doesn't change.
This way did take a little longer to code though, as excepted but the main issue in coding it was due to rust and mutable variables.

Although the faster solution is faster, it still could be faster. There are two points where i see the program being slow at.
1. Generating the path, the program has to work out the score for each cell and then generates the path from the back.
2. Generating the path, when an obsturction happens the path has to be fully regenerated instead of a section.

In order to implement either of these, it's going to take a lot more time which i don't want to deal with now (I might come back to it in the future though).
However both implentations would speed up the program due to less calculations.
If the path didn't need to be fully regenerated and instead we had a small section check or to generate the path at the same time as we find the path would probably help shave a few hundred miliseconds off if anything.

But for now, i'll enjoy an easy day in this group of very long confusing days.
