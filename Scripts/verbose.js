/**
 * A verbose logging utility class that provides various console logging methods with verbosity control.
 * 100% generated by AI because i'm lazy for this one... hehe.
 */
class Verbose {
  /**
   * Creates a new Verbose logger instance
   * @param {string|null} logName - Optional name for the logger instance
   * @param {string|null} colour - Optional color for log prefix
   */
  constructor(logName = null, colour = null) {
    this.__currentLogName = logName;
    this.__currentColour = colour;
  }

  /**
   * Internal function to get settings from localStorage
 * @private
 * @param {string} logName - Optional log name for specific verbose settings
 * @return {boolean} The setting value
 */
  __getSetting(logName = null) {
    if (logName) {
      return localStorage.getItem(`setting-Debug-verbose_${logName}`) === 'true';
    }
    return localStorage.getItem('setting-Debug-verbose') === 'true';
  }

  /**
   * Gets the current verbosity state
   * @return {boolean} The current verbosity state
   */
  get verbose() {
    if (!this.__getSetting()) {
      return false;
    }

    return this.__currentLogName ?
      this.__getSetting(this.__currentLogName) :
      true;
  }

  /**
   * Logs a message to the console if verbose mode is enabled
   * @param {...*} params - Parameters to log
   */
  log(...params) {
    logs.addLog(this.__currentLogName, logs.serveriety.LOG, ...params);
    if (!this.verbose) return;
    const prefix = this.__currentLogName ? [`%cVERBOSE_${this.__currentLogName}:%c`, `color: ${this.__currentColour || 'black'}`, ''] : [];
    console.log(...prefix, ...params);
  }

  /**
   * Logs a warning message to the console if verbose mode is enabled
   * @param {...*} params - Parameters to log
   */
  warn(...params) {
    logs.addLog(this.__currentLogName, logs.serveriety.WARN, ...params);
    if (!this.verbose) return;
    const prefix = this.__currentLogName ? [`%cVERBOSE_${this.__currentLogName}:%c`, `color: ${this.__currentColour || 'black'}`, ''] : [];
    console.warn(...prefix, ...params);
  }

  /**
   * Logs an error message to the console if verbose mode is enabled
   * @param {...*} params - Parameters to log
   */
  error(...params) {
    logs.addLog(this.__currentLogName, logs.serveriety.ERROR, ...params);
    if (!this.verbose) return;
    const prefix = this.__currentLogName ? [`%cVERBOSE_${this.__currentLogName}:%c`, `color: ${this.__currentColour || 'black'}`, ''] : [];
    console.error(...prefix, ...params);
  }

  /**
   * Logs an info message to the console if verbose mode is enabled
   * @param {...*} params - Parameters to log
   */
  info(...params) {
    logs.addLog(this.__currentLogName, logs.serveriety.INFO, ...params);
    if (!this.verbose) return;
    const prefix = this.__currentLogName ? [`%cVERBOSE_${this.__currentLogName}:%c`, `color: ${this.__currentColour || 'black'}`, ''] : [];
    console.info(...prefix, ...params);
  }

  /**
   * Logs a debug message to the console if verbose mode is enabled
   * @param {...*} params - Parameters to log
   */
  debug(...params) {
    logs.addLog(this.__currentLogName, logs.serveriety.DEBUG, ...params);
    if (!this.verbose) return;
    const prefix = this.__currentLogName ? [`%cVERBOSE_${this.__currentLogName}:%c`, `color: ${this.__currentColour || 'black'}`, ''] : [];
    console.debug(...prefix, ...params);
  }

  /**
   * Logs a stack trace to the console if verbose mode is enabled
   * @param {...*} params - Parameters to log
   */
  trace(...params) {
    logs.addLog(this.__currentLogName, logs.serveriety.TRACE, ...params);
    if (!this.verbose) return;
    const prefix = this.__currentLogName ? [`%cVERBOSE_${this.__currentLogName}:%c`, `color: ${this.__currentColour || 'black'}`, ''] : [];
    console.trace(...prefix, ...params);
  }

  /**
   * Logs an object to the console if verbose mode is enabled
   * @param {...*} params - Parameters to log
   */
  dir(...params) {
    logs.addLog(this.__currentLogName, logs.serveriety.DIR, ...params);
    if (!this.verbose) return;
    console.dir(...params);
  }

  /**
   * Logs tabular data to the console if verbose mode is enabled
   * @param {...*} params - Parameters to log
   */
  table(...params) {
    logs.addLog(this.__currentLogName, logs.serveriety.TABLE, ...params);
    if (!this.verbose) return;
    console.table(...params);
  }
}

class log {
  /**
   * Enum representing the severity levels of log messages.
   * @readonly
   * @enum {string}
   */
  serveriety = Object.freeze({
    LOG: 'LOG', WARN: 'WARN', ERROR: 'ERROR', INFO: 'INFO',
    DEBUG: 'DEBUG', TRACE: 'TRACE', DIR: 'DIR', TABLE: 'TABLE'
  });

  /** @type {{category: String, serveriety: String, params: any[], trace: String | undefined, time: dayjs}[]} */
  __logs = [];
  __callbacks = {};
  __elements = [];

  __limit = 1000;
  set limit(v) {
    if (Number.isNaN(v)) {
      return false;
    }
    this.__limit = Math.max(0, Math.min(1000, v));
  }
  get limit() { return this.__limit; }

  /**
  * Add a log to the list.
  * @param {String} category The category the log belongs to.
  * @param {serveriety} serveriety How bad the log is.
  * @param  {...any} params The log information.
  */
  addLog(category, serveriety, ...params) {
    let log = {
      category, serveriety, params,
    }
    log.trace = new Error().stack;
    log.time = dayjs();
    this.__logs.push(log);

    if (this.__logs.length > this.limit) {
      this.__logs.shift();
    }

    let callbacks = this.getCallback(category, serveriety);
    if (callbacks) callbacks.forEach(func => func(log));
    if (!document.getElementById('logs').hidden) this.displayLog(log);
  }

  /**
  *
  * @param {String} category The category to listen for.
  * @param {String} serveriety How bad of the log to listen for.
  * @param {(log: {category: String, serveriety: String, params: any[], trace: String | undefined, time: dayjs})} callback The function to call upon log being received.
  */
  addCallback(category, serveriety, callback) {
    let servList = this.__callbacks[category];
    if (servList == undefined) servList = {};
    let callList = servList[serveriety];
    if (callList == undefined) callList = [];
    callList.push(callback);
    servList[serveriety] = callList;
    this.__callbacks = servList;
  }

  getLogs(category, serveriety) {
    return this.__logs.filter((log) => log.category == category && log.serveriety == serveriety);
  }

  getCallback(category, serveriety) {
    let catList = this.__callbacks[category];
    if (!catList) return undefined;
    let servList = catList[serveriety];
    if (!servList) return undefined;
    return servList
  }

  /**
  * Display a log in the ui.
  * @param {{category: String, serveriety: String, params: any[], trace: String | undefined, time: dayjs}} log The log to display.
  */
  displayLog(log) {
    let logs = document.getElementById('logs');
    if (logs == null) return;

    /** @type {Node} */
    let template;
    if (this.__elements.length < this.limit) {
      template = logs.querySelector("[id='template']");
      if (template == null) return;
      template = template.cloneNode(true);
      template.id = '';
      template.classList.add('serveriety', log.serveriety);
      template.hidden = false;
      logs.appendChild(template);
      this.__elements.push(template);
    } else {
      template = this.__elements[0];
      logs.removeChild(template);
      logs.appendChild(template);
    }
    if (template == null) return;

    let icon = template.querySelector("[tag='icon']");
    if (icon) {
      switch (log.serveriety) {
        case 'LOG':
          icon.textContent = '📝'; // Example icon for LOG
          break;
        case 'WARN':
          icon.textContent = '⚠️'; // Example icon for WARN
          break;
        case 'ERROR':
          icon.textContent = '❌'; // Example icon for ERROR
          break;
        case 'INFO':
          icon.textContent = 'ℹ️'; // Example icon for INFO
          break;
        case 'DEBUG':
          icon.textContent = '🐛'; // Example icon for DEBUG
          break;
        case 'TRACE':
          icon.textContent = '🔍'; // Example icon for TRACE
          break;
        case 'DIR':
          icon.textContent = '📂'; // Example icon for DIR
          break;
        case 'TABLE':
          icon.textContent = '📊'; // Example icon for TABLE
          break;
        default:
          icon.textContent = '❓'; // Default icon for unknown serveriety
          break;
      }
    }

    let category = template.querySelector("[tag='category']")
    if (category) category.textContent = log.category;

    let time = template.querySelector("[tag='time']")
    if (time) time.textContent = log.time.format('HH:mm:ss:SSS');

    let message = template.querySelector("[tag='message']")
    if (message) {
      message.textContent = log.params.toString();
      if (log.serveriety == this.serveriety.TRACE) {
        message.textContent = `${message.textContent} ${log.trace}`;
      }
    }
  }

  refreshDisplay() {
    let logs = document.getElementById('logs');
    if (logs == null) return;
    Array.from(logs.children).forEach(child => {
      if (child.id !== 'template') {
        logs.removeChild(child);
      }
    });
    this.__logs.forEach((log) => { console.log(log); this.displayLog(log) });
  }

  show() {
    this.refreshDisplay();
    document.getElementById('logs').hidden = false;
  }
  hide() {
    document.getElementById('logs').hidden = true;
  }
}

let logs = new log();
